{"version":3,"sources":["components/Navbar.jsx","components/WarningMessage.jsx","components/Search.jsx","components/Home.jsx","components/Lemma.jsx","components/macraToHyphens.js","components/WordFromJson.jsx","components/Lemmata.jsx","components/CountdownHome.jsx","components/Countdown.jsx","components/AnagramsHome.jsx","components/Anagrams.jsx","components/Footer.jsx","App.js","serviceWorker.js","index.js"],"names":["Navbar","props","input","replace","currentPage","root","inputTrunc","length","substr","react_default","a","createElement","className","react_router_dom","to","title","WarningMessage","Search","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","handleInput","e","setState","target","value","fromUrl","handleMenu","menu","handleKeyUp","keyCode","redirect","state","react_router","pathname","concat","prefix","window","location","push","onChange","onKeyUp","Component","Home","document","src_components_Navbar","src_components_WarningMessage","src_components_Search","Lemma","lemma","partOfSpeech","toLowerCase","meaning","scansion","forms","cognatesMessage","cognates","macraToHyphens","macronizedWord","toDots","WordFromJson","randomWord","words","Math","ceil","random","Word","foundWord","find","word","mappedRhymes","mappedAnagrams","wordLemmata","mappedLemmata","plainInput","mappedDics","dictionaries","map","dic","index","key","href","Formula","Dictionary","filter","sort","b","rhyme","anagram","LemmaArray","foundLemma","lemmata","jsonLemma","mappedForms","includes","form","lemmaForCognates","Root","mappedCognates","cognate","components_Lemma","Meaning","Scansion","Lemmata","randomLemma","lemmaObjects","CountdownHome","delChars","superword","subword","string","chars","split","i","subwordObjects","wordObjects","Countdown","mappedWords","AnagramsHome","Anagrams","arrayOfAnagrams","allSubwords","console","log","remainingLetters","subwordsOne","j","remainingLettersOne","subwordsTwo","k","remainingLettersTwo","subwordsThree","l","anagrams","Footer","App","path","exact","component","src_components_Footer","Boolean","hostname","match","ReactDOM","render","src_App_0","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.d369c4d9.chunk.js","sourcesContent":["import React from 'react'\r\nimport {Link} from 'react-router-dom'\r\nimport './Navbar.css'\r\n\r\nconst Navbar = (props) => {\r\n    const input = props.input.replace(/-/g,\"\").replace(/\\./g,\"\")\r\n    const currentPage = props.currentPage\r\n    let root = \"../\"\r\n    if (currentPage === \"word\") {\r\n        root = \"./\"\r\n    }\r\n    let inputTrunc = input\r\n    if (inputTrunc.length>9) {\r\n        inputTrunc = input.substr(0,9)\r\n    }\r\n    return (\r\n        <ul className=\"navbar\">\r\n            {currentPage===\"word\" ? null : <li><Link to={root+input} title=\"Find lemmata, rhymes, etc.\">Latin word look-up</Link></li>}\r\n            {currentPage===\"countdown\" ? null : <li><Link to={root+\"countdown/\"+input} title=\"Find subwords\">Play Latin Countdown</Link></li>}\r\n            {currentPage===\"anagrams\" ? null : <li><Link to={root+\"anagrams/\"+inputTrunc} title=\"Find anagrams\">Find Latin anagrams</Link></li>}\r\n        </ul>\r\n    )\r\n}\r\n\r\nexport default Navbar","import React from 'react';\r\nimport './WarningMessage.css'\r\n\r\nlet WarningMessage = () => {\r\n    return (\r\n        <p className=\"warning-message\">\r\n            Nota bene &mdash; I&rsquo;m still developing this website.<br />\r\n            • It may be a bit slow to load initially, but searches via the input below will be quicker.<br />\r\n            • All the data have been compiled by me, so there are occasional errors. Please check words in other dictionaries; there are links at the base of the page.<br />\r\n            • There are over 90,000 words on this site, representing more than 11,000 lemmata, but there are many more possible in Latin. I&rsquo;m frequently adding new words, but I have some way to go! In particular, prefixed words and words stressed on a grammatical ending or a common suffix have generally been omitted.<br />\r\n            • At the moment, the &ldquo;rhymes&rdquo; are determined under classical pronunciation, so (e.g.) vowel length matters. In the future, you will have other options for what kinds of rhymes you want to find.<br />\r\n            • Have fun searching!\r\n        </p>\r\n    )\r\n}\r\n\r\nexport default WarningMessage","import React, {Component} from \"react\";\r\nimport {Link, Redirect} from \"react-router-dom\";\r\nimport \"./Search.css\"\r\n\r\nclass Search extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            input: \"\",\r\n            menu: \"Perfect rhyme\",\r\n            redirect: false,\r\n            fromUrl: true\r\n        }\r\n    }\r\n\r\n    // This handles the <input> value.\r\n    handleInput = (e) => {\r\n        this.setState({input: e.target.value, fromUrl: false})\r\n    }\r\n\r\n    // This handles the menu value.\r\n    handleMenu = (e) => {\r\n        this.setState({menu: e.target.value})\r\n    }\r\n    \r\n    // This is to search when the enter key is pressed within the <input>.\r\n    handleKeyUp = (e) => {\r\n        if (e.keyCode === 13 ) {\r\n            this.setState({redirect: true, fromUrl: true})\r\n        }\r\n    }\r\n\r\n    render() {\r\n        // This gives warnings in the console because we're setting state within the render method. \r\n        // We need to set state back to redirect:false to avoid infinite redirects.\r\n        if (this.state.redirect) {\r\n            this.setState({redirect: false})\r\n            return <Redirect to={{pathname: `/${this.props.prefix}${this.state.input}`, state: {input: window.location.pathname.replace(\"/\",\"\"), redirect: false}}} push={true}/>\r\n        }\r\n        else {\r\n            return (\r\n                <div className=\"search\">\r\n                    {/* The box the word will be typed into */}\r\n                    <input \r\n                     className=\"search-input\"\r\n                     value={ this.state.fromUrl ? window.location.pathname.replace(\"/lemma/\",\"\").replace(\"/countdown\",\"\").replace(\"/anagrams\",\"\").replace(\"/\",\"\") : this.state.input }\r\n                     onChange={this.handleInput}\r\n                     onKeyUp={this.handleKeyUp}\r\n                     />\r\n                    {/* The menu to change the rhyme type displayed NOT HAVING AN EFFECT YET*/}\r\n                    {/* <div className=\"dropdown\">\r\n                        <input\r\n                        className=\"menu-input\"\r\n                        value={this.state.menu}\r\n                        onChange={this.handleMenu}\r\n                        />\r\n                        <div className=\"dropdown-content\">\r\n                            <Link className=\"dropdown-link\" to={\"/perfect/\"+this.state.input}>Perfect rhyme</Link>\r\n                            <Link className=\"dropdown-link\" to={\"/rvfc/\"+this.state.input}>Rhyme vowels and final consonants</Link>\r\n                            <Link className=\"dropdown-link\" to={\"/ecclesperfect/\"+this.state.input}>Ecclesiastical perfect rhyme</Link>\r\n                            <Link className=\"dropdown-link\" to={\"/consonyms/\"+this.state.input}>All consonants (consonyms)</Link>\r\n                        </div>\r\n                    </div> */}\r\n                    {/* What would be a \"submit\" button in a normal form */}\r\n                    <Link\r\n                     className=\"search-link\" \r\n                     to={\"/\"+this.props.prefix+this.state.input} \r\n                     title={`Search for ${this.state.input}`}\r\n                     >Search!</Link>    \r\n                </div>\r\n            )\r\n        }\r\n    }\r\n}\r\n\r\nexport default Search","import React from 'react';\r\nimport Navbar from './Navbar';\r\nimport WarningMessage from './WarningMessage';\r\nimport Search from './Search';\r\n\r\nlet Home = () => {\r\n    document.title = \"Duncan Ritchie’s velut\"\r\n    return (\r\n        <div className=\"home\">\r\n            <h1><span className=\"title\">velut</span> &mdash; Vocābulōrum Excellentium Latīnōrum Ūtilēs Tabulae</h1>\r\n            <Navbar input=\"\" currentPage=\"word\"/>\r\n            <p>Welcome to my Useful Tables of Excellent Latin Vocabulary!</p>\r\n            <p>Search for a Latin word using the searchbar below!</p>\r\n            <WarningMessage />\r\n            <Search prefix=\"\" />\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Home","import React from 'react';\r\n\r\nlet Lemma = (props) => {\r\n    return (\r\n        <div className=\"lemma\">\r\n            <h2>{props.lemma}</h2>\r\n            <p>Part of speech: {props.partOfSpeech.toLowerCase()}</p>\r\n            <p>Meaning: {props.meaning}</p>\r\n            {props.scansion ? <p>Scansion of lemma: {props.scansion}</p> : null}\r\n            {props.forms ? <p>Forms: {props.forms}</p> : null}\r\n            <p>{props.cognatesMessage ? props.cognatesMessage : <span>Cognates: {props.cognates}</span>}</p>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Lemma","const macraToHyphens = (macronizedWord) => {\r\n    // Macra are converted to hyphens.\r\n    let toHyphens = macronizedWord.replace(/\\u0100/g,\"A-\").replace(/\\u0101/g,\"a-\").replace(/\\u0112/g,\"E-\").replace(/\\u0113/g,\"e-\").replace(/\\u012A/g,\"I-\").replace(/\\u012B/g,\"i-\").replace(/\\u014C/g,\"O-\").replace(/\\u014D/g,\"o-\").replace(/\\u016A/g,\"U-\").replace(/\\u016B/g,\"u-\").replace(/\\u1E7B/g,\"u-.\").replace(/\\u0232/g,\"Y-\").replace(/\\u0233/g,\"y-\")\r\n    // Acutes are converted to dots.\r\n    let toDots = toHyphens.replace(/\\u00C1/g,\"A.\").replace(/\\u00C9/g,\"E.\").replace(/\\u00CD/g,\"I.\").replace(/\\u00D3/g,\"O.\").replace(/\\u00DA/g,\"U.\").replace(/\\u00DD/g,\"Y.\").replace(/\\u00EA/g,\"a.\").replace(/\\u00E9/g,\"e.\").replace(/\\u00ED/g,\"i.\").replace(/\\u00F3/g,\"o.\").replace(/\\u00FA/g,\"u.\").replace(/\\u00FD/g,\"y.\")\r\n    // Diaereses are likewise converted to dots.\r\n    toDots = toDots.replace(/\\u00E4/g,\"a.\").replace(/\\u00EB/g,\"e.\").replace(/\\u00EF/g,\"i.\").replace(/\\u00F6/g,\"o.\").replace(/\\u00FC/g,\"u.\").replace(/\\u00FF/g,\"y.\")\r\n    return toDots\r\n}\r\n\r\nexport default macraToHyphens","import React from 'react';\r\nimport {Link} from \"react-router-dom\";\r\nimport Search from \"./Search\";\r\nimport words from \"../data/words_8fields.json\";\r\nimport lemmata from \"../data/lemmata.json\";\r\nimport dictionaries from \"../data/dictionaries.json\";\r\nimport Lemma from \"./Lemma\";\r\nimport macraToHyphens from \"./macraToHyphens\";\r\nimport WarningMessage from \"./WarningMessage\";\r\nimport Navbar from \"./Navbar\"\r\n\r\nlet WordFromJson = (props) => {\r\n    // The word searched for comes from the window location.\r\n    let input = window.location.pathname.replace(\"/word\",\"\").replace(\"/\",\"\");\r\n    document.title = input+\" on velut\"\r\n    // Let's pick a random word to show if no words match the search.\r\n    let randomWord = words[Math.ceil(Math.random()*words.length)].Word;\r\n    // foundWord is the first object that matches the input.\r\n    // It looks for an exact match, then ignores macra and looks again, then ignores case and looks again.\r\n    let foundWord = words.find(word=>{return macraToHyphens(word.Word)===input})\r\n    if (!foundWord) {\r\n        foundWord = words.find(word=>{return word.Word===input})\r\n    }\r\n    if (!foundWord) {\r\n        foundWord = words.find(word=>{return word[\"No macra\"]===input.replace(/[-/.]/g,\"\").replace(/\\[.*\\]/g,\"\")})\r\n    }\r\n    if (!foundWord) {\r\n        foundWord = words.find(word=>{return word[\"No macra\"].toLowerCase()===input.replace(/[-/.]/g,\"\").replace(/\\[.*\\]/g,\"\").toLowerCase()})\r\n    }\r\n    let mappedRhymes = [];\r\n    let mappedAnagrams = [];\r\n    let wordLemmata = [];\r\n    let mappedLemmata = [];\r\n    // Let's do dictionaries.\r\n    let plainInput = input.replace(/-/g,\"\").replace(/\\./g,\"\")\r\n    let mappedDics = dictionaries.map((dic,index)=>{\r\n        return <span key={index}><a href={dic.Formula.replace(\"INPUT\",plainInput)} title={\"Search \"+dic.Dictionary+\" for \"+plainInput}>{dic.Dictionary}</a>{index===dictionaries.length-1 ? \"\" : \",\"} </span>\r\n    })\r\n    if (foundWord) {\r\n        // Let's set the document title to the word we found.\r\n        document.title = foundWord[\"Word\"]+\" on velut\"\r\n        // Let's find the rhymes.\r\n        let rhymes = words.filter((word)=>{return word[\"Perfect rhyme\"]===foundWord[\"Perfect rhyme\"]})\r\n        // The rhymes get sorted by Sort Column. Uncomment the enclosing if-else-statement to sort by syllable count.\r\n        let sortedRhymes = rhymes.sort((a,b)=>{\r\n            // if (a[\"Scansion\"].length===b[\"Scansion\"].length) {\r\n                if (a[\"Sort column\"].replace(/•/g,\"-\")>b[\"Sort column\"].replace(/•/g,\"-\")) {\r\n                    return 1\r\n                }\r\n                else {\r\n                    return -1\r\n                }\r\n            // }\r\n            // else {\r\n            //     return a[\"Scansion\"].length-b[\"Scansion\"].length\r\n            // }\r\n        })\r\n        // A react-router-dom Link is rendered for every rhyme.\r\n        mappedRhymes = sortedRhymes.map((rhyme,index)=>{return (\r\n            <span key={index}><Link to={\"/\"+macraToHyphens(rhyme.Word)} title={rhyme.Word}>{rhyme.Word}</Link> </span>\r\n        )})\r\n        // Let's find the anagrams.\r\n        let anagrams = words.filter((word)=>{return word[\"Alph order no macra\"]===foundWord[\"Alph order no macra\"]})\r\n        // The anagrams get sorted alphabetically.\r\n        let sortedAnagrams = anagrams.sort((a,b)=>{\r\n            if (a[\"No macra\"].toLowerCase()>b[\"No macra\"].toLowerCase()) {\r\n                return 1\r\n            }\r\n            else {\r\n                return -1\r\n            }\r\n        })\r\n        // A react-router-dom Link is rendered for every anagram.\r\n        mappedAnagrams = sortedAnagrams.map((anagram,index)=>{return (\r\n            <span key={index}><Link to={\"/\"+macraToHyphens(anagram.Word)} title={anagram.Word}>{anagram.Word}</Link> </span>\r\n        )})\r\n        // Let's do the lemmata. We will render an element for every lemma listed against the input.\r\n        wordLemmata = foundWord.LemmaArray\r\n        mappedLemmata = wordLemmata.map((lemma,index)=>{\r\n            // Let's find the lemma in the Json.\r\n            let foundLemma = lemmata.find(jsonLemma=>{return jsonLemma.Lemma===lemma})\r\n            if (foundLemma) {\r\n                // Let's get the inflected forms.\r\n                let forms = words.filter(word=>{return word.LemmaArray.includes(foundLemma.Lemma)})\r\n                // Let's render a Link for every form.\r\n                let mappedForms = forms.map((form,index)=>{\r\n                    return <span key={index}><Link title={form.Word} to={\"/\"+macraToHyphens(form.Word)}>{form.Word}</Link> </span>\r\n                })\r\n                // Let's get the cognates.\r\n                let cognates = lemmata.filter((lemmaForCognates)=>{return lemmaForCognates.Root === foundLemma.Root});\r\n                // If no etymology is given in the data, a message should appear in the cognates paragraph.\r\n                let cognatesMessage = \"\";\r\n                if (!foundLemma.Root) {\r\n                    cognatesMessage = \"I have not assigned cognates for this lemma, sorry!\"\r\n                }\r\n                // This sorts the cognates alphabetically.\r\n                let sortedCognates = cognates.sort((a,b)=>{\r\n                    if(b[\"No Macra\"].toLowerCase() < a[\"No Macra\"].toLowerCase()) {\r\n                        return 1\r\n                    } \r\n                    else {\r\n                        return -1\r\n                    }\r\n                });\r\n                // A react-router-dom Link is rendered for every cognate.\r\n                let mappedCognates = sortedCognates.map((cognate,index)=>{\r\n                    return <span key={index}><Link to={`/${macraToHyphens(cognate.Lemma).replace(/\\[.*\\]/g,\"\")}`} key={index} title={cognate.Lemma}> {cognate.Lemma}</Link> </span>\r\n                })\r\n                // Cognates are done. Let's put everything into the Lemma element.\r\n                return (\r\n                    <Lemma \r\n                    key={index} \r\n                    lemma={foundLemma.Lemma} \r\n                    partOfSpeech={foundLemma[\"Part of Speech\"]} \r\n                    meaning={foundLemma.Meaning} \r\n                    scansion={foundLemma.Scansion}\r\n                    forms={mappedForms}\r\n                    cognates={mappedCognates}\r\n                    cognatesMessage={cognatesMessage}\r\n                    /> \r\n                )\r\n            }\r\n            else {\r\n                return null\r\n            }\r\n        })\r\n            \r\n    }\r\n    return (\r\n        <div className=\"word\">\r\n            <h1><span className=\"title\">velut</span> &mdash; {foundWord ? foundWord.Word : input}</h1>\r\n            <Navbar input={input} currentPage=\"word\"/>\r\n            <p>Welcome to my Useful Tables of Excellent Latin Vocabulary!</p>\r\n            <WarningMessage/>\r\n            <Search prefix=\"\"/>\r\n            <div className=\"divider\"/>\r\n            {foundWord ? <div><p>The word <strong>{foundWord.Word}</strong> could scan as {foundWord.Scansion}</p>\r\n            <p>Perfect rhymes: {mappedRhymes}</p>\r\n            <p>Anagrams: {mappedAnagrams}</p>\r\n            <div className=\"divider\"/>\r\n            <p><strong>{foundWord.Word}</strong> belongs to the following {wordLemmata.length} {wordLemmata.length===1 ? \"lemma\" : \"lemmata\"}:</p></div> : <p>Nothing was found. Try <Link to={\"/\"+macraToHyphens(randomWord)} title={randomWord}>{randomWord}</Link>.</p>}\r\n            {mappedLemmata ? mappedLemmata : null}\r\n            <div className=\"divider\"/>\r\n            <div className=\"divider\"/>\r\n            <p className=\"dictionaries\">Links to external sites: {mappedDics}</p>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default WordFromJson","import React from 'react';\r\nimport {Link} from \"react-router-dom\";\r\nimport Search from \"./Search\";\r\nimport lemmata from \"../data/lemmata.json\";\r\nimport words from \"../data/words_8fields.json\";\r\nimport Lemma from \"./Lemma\"\r\n\r\nlet Lemmata = (props) => {\r\n    // The word searched for comes from the window location.\r\n    let input = window.location.pathname.replace(\"/lemma\",\"\").replace(\"/\",\"\");\r\n    document.title = input+\" on velut\"\r\n    // Let's pick a random lemma to show if no lemmata match the search.\r\n    let randomLemma = lemmata[Math.ceil(Math.random()*lemmata.length)][\"No Macra\"];\r\n    // We're filtering the Json data to lemmata that match the search.\r\n    let lemmaObjects = lemmata.filter((lemma)=>{return lemma[\"No Macra\"].toLowerCase() === input.toLowerCase()});\r\n    // mappedLemmata will be an array of JSX elements.\r\n    let mappedLemmata = lemmaObjects.map((lemma,index)=>{\r\n        // Let's get the inflected forms.\r\n        let forms = words.filter(word=>{return word.LemmaArray.includes(lemma.Lemma)})\r\n        // Let's render a Link for every form.\r\n        let mappedForms = forms.map((form,index)=>{return <Link key={index} title={form[\"No macra\"]} to={\"/\"+form[\"No macra\"]}>{form.Word} </Link>})\r\n        // Let's get the cognates.\r\n        let cognates = lemmata.filter((lemmaForCognates)=>{return lemmaForCognates.Root === lemma.Root});\r\n        // If no etymology is given in the data, a message should appear in the cognates paragraph.\r\n        let cognatesMessage = \"\";\r\n        if (!lemma.Root) {\r\n            cognatesMessage = \"I have not assigned cognates for this word, sorry!\"\r\n        }\r\n        // This sorts the cognates alphabetically.\r\n        let sortedCognates = cognates.sort((a,b)=>{\r\n            if(b[\"No Macra\"].toLowerCase() < a[\"No Macra\"].toLowerCase()) {\r\n                return 1\r\n             } \r\n            else {\r\n                return -1\r\n            }\r\n        });\r\n        // A react-router Link is rendered for every cognate.\r\n        let mappedCognates = sortedCognates.map((cognate,index)=>{\r\n            return <Link to={`/lemma/${cognate[\"No Macra\"]}`} key={index} title={cognate[\"No Macra\"]}> {cognate.Lemma} </Link>\r\n        })\r\n        // Cognates are done. Let's put everything into the Lemma element.\r\n        return (\r\n            <Lemma \r\n            key={index} \r\n            lemma={lemma.Lemma} \r\n            partOfSpeech={lemma[\"Part of Speech\"]} \r\n            meaning={lemma.Meaning} \r\n            scansion={lemma.Scansion} \r\n            forms={mappedForms}\r\n            cognates={mappedCognates}\r\n            cognatesMessage={cognatesMessage}\r\n            /> \r\n        )\r\n    })\r\n    // Building the actual page.\r\n    return (\r\n        <div className=\"word\">\r\n            <h1><span className=\"title\">velut</span> &mdash; lemma &mdash; {input}</h1>\r\n            <p>Welcome to my Useful Tables of Excellent Latin Vocabulary!</p>\r\n            <p>I&rsquo;m still in the initial stages of creating this app&hellip;</p>\r\n            {/* Search bar and submit link */}\r\n            <Search prefix=\"lemma/\" />\r\n            {/* Telling the user what they searched for and how many results were found. */}\r\n            <p>\r\n                You searched for the lemma <strong>{window.location.pathname.replace(\"/lemma\",\"\").replace(\"/\",\"\")}</strong>. {lemmaObjects.length} matching {lemmaObjects.length===1 ? \"lemma\" : \"lemmata\"} found.\r\n            </p>\r\n            {/* If there are no results, it suggests the random lemma. If there are results, they're displayed. */}\r\n            {lemmaObjects.length===0 ? \r\n                <p>\r\n                    Try searching for a Latin lemma, such as <strong><Link to={\"./\"+randomLemma} title={randomLemma}>{randomLemma}</Link></strong>. \r\n                    (If my app is vaguely working; maybe it&rsquo;s not!)\r\n                </p>\r\n            : mappedLemmata}\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Lemmata","import React from 'react';\r\nimport Search from './Search'\r\nimport Navbar from './Navbar'\r\n\r\nconst CountdownHome = () => {\r\n    return (\r\n        <div className=\"countdown-home\">\r\n            <h1><span className=\"title\">velut</span> &mdash; Countdown</h1>\r\n            <Navbar input=\"\" currentPage=\"countdown\"/>\r\n            <p>This will help you find Latin words that can be made with the letters you specify. Type some letters below!</p>\r\n            <Search prefix=\"countdown/\" />\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default CountdownHome","import React from 'react';\r\nimport {Link} from 'react-router-dom';\r\nimport Search from './Search'\r\nimport Navbar from './Navbar'\r\nimport words from \"../data/words_8fields.json\";\r\n\r\n// delChars() removes every character (case-insensitive) in the second parameter from the first parameter, \r\n// e.g. delChars(\"Duncanus\",\"nunc\") = \"Daus\"\r\n// e.g. delChars(\"Rīchardus\",\"hinc\") = \"Rīardus\"\r\n// e.g. delChars(\"Richardus\",\"hinc\") = \"Rardus\"\r\n\r\nconst delChars = (superword,subword) => {\r\n    let string = superword.toLowerCase()\r\n    subword = subword.toLowerCase()\r\n    let chars = subword.split(\"\")\r\n    for (let i=0; i<subword.length; i++) {\r\n        string = string.replace(chars[i],\"\")\r\n    }\r\n    return string\r\n}\r\n\r\n// subwordObjects() returns an array of objects. words.json should be passed in as the second parameter.\r\n\r\nconst subwordObjects = (input,wordObjects) => {\r\n    let filteredWordObjects = wordObjects.filter(word=>{\r\n        if (delChars(input.toLowerCase(),word[\"Alph order no macra\"]).length === input.length-word[\"Alph order no macra\"].length) {\r\n            return true\r\n        }\r\n        else {\r\n            return false\r\n        }\r\n    })\r\n    let sortedWordObjects = filteredWordObjects.sort((a,b)=>{\r\n        if (a.Word.length > b.Word.length) {\r\n            return -1\r\n        }\r\n        else if (a.Word.length < b.Word.length) {\r\n            return 1\r\n        }\r\n        else if (a[\"No macra\"] < b[\"No macra\"]) {\r\n                return -1\r\n            }\r\n            else {\r\n                return 1\r\n            }\r\n    })\r\n    return sortedWordObjects\r\n}\r\n\r\n// <Countdown/> is a JSX element rendered at /countdown/:input\r\n\r\nconst Countdown = () => {\r\n    let input = window.location.pathname.replace(\"/countdown\",\"\").replace(\"/\",\"\")\r\n    document.title = \"Subwords of \"+input+\" on velut\"\r\n    let sortedWordObjects = subwordObjects(input,words)\r\n    let mappedWords = sortedWordObjects.map((word,index)=>{\r\n        if (delChars(input,word[\"Alph order no macra\"])) {\r\n            return <span key={index}><Link to={\"./\"+delChars(input,word[\"Alph order no macra\"])} title={\"delete \"+word.Word+\" from \"+input}>{word.Word}</Link> </span>\r\n        }\r\n        else {\r\n            return <span key={index}><strong>{word.Word}</strong> </span>\r\n        }\r\n    })\r\n    return (\r\n        <div className=\"word\">\r\n            <h1><span className=\"title\">velut</span> &mdash; Countdown &mdash; {input}</h1>\r\n            <Navbar input={input} currentPage=\"countdown\"/>\r\n            {mappedWords.length ? (\r\n                <div>\r\n                    <Search prefix=\"countdown/\"/>\r\n                    <p>Here are the Latin words that can be made out of letters in {input}. You can click on a word (other than a perfect anagram) to delete its letters from {input}.</p>\r\n                    <p>{mappedWords}</p>\r\n                </div>\r\n            ) : (\r\n                <p>No words found! Try a different input, such as <Link to=\"./DuncanusRichardus\" title=\"Subwords of DuncanusRichardus\">DuncanusRichardus</Link></p>\r\n            )}\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Countdown\r\nexport {delChars, subwordObjects}","import React from 'react';\r\nimport Search from './Search'\r\nimport Navbar from './Navbar'\r\n\r\nconst AnagramsHome = () => {\r\n    return (\r\n        <div className=\"anagrams-home\">\r\n            <h1><span className=\"title\">velut</span> &mdash; Anagrams</h1>\r\n            <Navbar input=\"\" currentPage=\"anagrams\"/>\r\n            <p>This will help you find Latin phrases that are anagrams! Search for something (up to about a dozen letters)!</p>\r\n            <Search prefix=\"anagrams/\" />\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default AnagramsHome","import React from 'react';\r\nimport words from \"../data/words_8fields.json\";\r\nimport {delChars, subwordObjects} from \"./Countdown\"\r\nimport Search from './Search'\r\nimport Navbar from './Navbar'\r\n\r\n// anagrams() returns an array of strings that are multiword anagrams of input\r\n\r\nconst anagrams = (input) => {\r\n    input = input.toLowerCase()\r\n    let arrayOfAnagrams = []\r\n    let allSubwords = subwordObjects(input,words)\r\n    console.log(\"Number of subwords: \"+allSubwords.length)\r\n    for (let i=0; i<allSubwords.length; i++) {\r\n        let remainingLetters = delChars(input,allSubwords[i][\"Alph order no macra\"])\r\n        if (remainingLetters.length === 0) {\r\n            arrayOfAnagrams.push(allSubwords[i][\"Word\"])\r\n        }\r\n        else {\r\n            let subwordsOne = subwordObjects(remainingLetters,allSubwords)\r\n            for (let j=0; j<subwordsOne.length; j++) {\r\n                let remainingLettersOne = delChars(remainingLetters,subwordsOne[j][\"Alph order no macra\"])\r\n                if (remainingLettersOne.length === 0) {\r\n                    arrayOfAnagrams.push(allSubwords[i][\"Word\"]+\" \"+subwordsOne[j][\"Word\"])\r\n                }\r\n                else {\r\n                    let subwordsTwo = subwordObjects(remainingLettersOne,allSubwords)\r\n                    for (let k=0; k<subwordsTwo.length; k++) {\r\n                        let remainingLettersTwo = delChars(remainingLettersOne,subwordsTwo[k][\"Alph order no macra\"])\r\n                        if (remainingLettersTwo.length === 0) {\r\n                            arrayOfAnagrams.push(allSubwords[i][\"Word\"]+\" \"+subwordsOne[j][\"Word\"]+\" \"+subwordsTwo[k][\"Word\"])\r\n                        }\r\n                        else {\r\n                            let subwordsThree = subwordObjects(remainingLettersTwo,allSubwords)\r\n                            for (let l=0; l<subwordsThree.length; l++) {\r\n                                let remainingLettersThree = delChars(remainingLettersTwo,subwordsThree[l][\"Alph order no macra\"])\r\n                                if (remainingLettersThree.length === 0) {\r\n                                    arrayOfAnagrams.push(allSubwords[i][\"Word\"]+\" \"+subwordsOne[j][\"Word\"]+\" \"+subwordsTwo[k][\"Word\"]+\" \"+subwordsThree[l][\"Word\"])\r\n                                }\r\n                                else {\r\n                                    // let subwordsFour = subwordObjects(remainingLettersThree,allSubwords)\r\n                                    // for (let m=0; m<subwordsFour.length; m++) {\r\n                                    //     let remainingLettersFour = delChars(remainingLettersThree,subwordsFour[m][\"Alph order no macra\"])\r\n                                    //     arrayOfAnagrams.push(allSubwords[i][\"Word\"]+\" \"+subwordsOne[j][\"Word\"]+\" \"+subwordsTwo[k][\"Word\"]+\" \"+subwordsThree[l][\"Word\"]+\" \"+subwordsFour[m][\"Word\"]+\" - \"+remainingLettersFour)\r\n                                    // }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return arrayOfAnagrams\r\n}\r\n\r\nconst Anagrams = () => {\r\n    let input = window.location.pathname.replace(\"/anagrams\",\"\").replace(\"/\",\"\")\r\n    document.title = \"Anagrams of \"+input+\" on velut\"\r\n    let mappedAnagrams = anagrams(input).map((anagram,index)=>{\r\n        return <span key={index}>{anagram}<br/></span>\r\n    })\r\n    return (\r\n        <div className=\"word\">\r\n            <h1><span className=\"title\">velut</span> &mdash; Anagrams &mdash; {input}</h1>\r\n            <Navbar input={input} currentPage=\"anagrams\"/>\r\n            <Search prefix=\"anagrams/\" />\r\n            <p>{mappedAnagrams.length ? mappedAnagrams : \"No anagrams found. Try another search.\"}</p>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Anagrams","import React from 'react';\r\nimport \"../App.css\"\r\nimport \"./Footer.css\"\r\n\r\nlet Footer = () => {\r\n    return (\r\n        <div className=\"footer\">\r\n            <p>&copy; Duncan Ritchie. Data do not include all lemmata in Latin, or all forms of many lemmata. See my <a href=\"https://www.duncanritchie.co.uk\" title=\"Duncan Ritchie&rsquo;s website\">website</a>.</p>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Footer","import React, { Component } from 'react';\r\nimport {BrowserRouter as Router, Route, Switch} from \"react-router-dom\";\r\nimport Home from \"./components/Home\";\r\nimport WordFromJson from \"./components/WordFromJson\";\r\nimport Lemmata from \"./components/Lemmata\";\r\nimport CountdownHome from \"./components/CountdownHome\";\r\nimport Countdown from \"./components/Countdown\";\r\nimport AnagramsHome from \"./components/AnagramsHome\";\r\nimport Anagrams from \"./components/Anagrams\";\r\nimport Footer from \"./components/Footer\";\r\nimport './App.css';\r\n\r\nclass App extends Component {\r\n  render() {\r\n    return (\r\n      <div className=\"App\">\r\n        <Router>\r\n          <Switch>\r\n            <Route path=\"/\" exact component={Home} />\r\n            <Route path=\"/lemma/:word\" component={Lemmata} />\r\n            <Route path=\"/countdown/:word\" component={Countdown} />\r\n            <Route path=\"/countdown\" component={CountdownHome} />\r\n            <Route path=\"/anagrams/:word\" component={Anagrams} />\r\n            <Route path=\"/anagrams\" component={AnagramsHome} />\r\n            <Route path=\"/:word\" component={WordFromJson} />\r\n          </Switch>\r\n          <Footer />\r\n        </Router>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\nserviceWorker.unregister();"],"sourceRoot":""}